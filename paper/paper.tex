\documentclass[11 pt]{extarticle}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[shortlabels, inline]{enumitem}
\usepackage{mleftright}
\usepackage{array}
\usepackage{gensymb}
\usepackage[english]{babel}
\usepackage{setspace}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage[numbers]{natbib}
\usepackage{listings,xcolor}
\usepackage{todonotes}
\newcommand\mdoubleplus{\mathbin{+\mkern-10mu+}}
\usepackage{tikz-cd}
% http://tex.stackexchange.com/q/169557/5764
\usepackage{mathtools}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}
\newcommand{\vectorproj}[2][]{\textit{proj}_{\vect{#1}}\vect{#2}}
\newcommand{\vect}{\mathbf}
\pgfplotsset{width=10cm,compat=1.9}


\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Mat}{\text{Mat}}
\newcommand{\sgn}{\text{sgn}}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\img}{im}

\let\hom\relax% Set equal to \relax so that LaTeX thinks it's not defined
\DeclareMathOperator{\hom}{Hom}
\newcommand{\Char}{\text{char}}
\newcommand{\defeq}{\overset{\text{\tiny def}}{=}}

\theoremstyle{remark}
\newtheorem{lemma}{Lemma}


\newenvironment{amatrix}[1]{%
  \left[\begin{array}{@{}*{#1}{c}|c@{}}
          }{%
        \end{array}\right]
    }

    \renewcommand\qedsymbol{$\blacksquare$}

    \newenvironment{theorem}[2][Theorem]{\begin{trivlist}
      \item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
    \newenvironment{theorem*}[1][Theorem:]{\begin{trivlist}
      \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
    \newenvironment{exercise}[2][Exercise]{\begin{trivlist}
      \item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
    \newenvironment{reflection}[2][Reflection]{\begin{trivlist}
      \item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
    \newenvironment{proposition}[2][Proposition]{\begin{trivlist}
      \item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
    \newenvironment{corollary}[2][Corollary]{\begin{trivlist}
      \item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

    \begin{document}
\onehalfspacing

\title{Zero-Knowledge Credentials for Smart Contracts}
\author{Lucas Switzer, Tjaden Hess}

\maketitle

\begin{abstract}
	Public blockchains present unique opportunities for the implementation of
	autonomous and trustless systems, but suffer from trade-offs between
	privacy and expressivity. In this paper we present an implementation of a
	zkSNARK-based
	anonymous credential scheme for the Ethereum blockchain and give
	benchmarks for usage costs. We present as well an example application.
\end{abstract}

\section{Introduction}
While blockchains have found use cases in publicly accessible distributed
systems, they pose a challenge in that due to their public nature it is
currently impossible to attest to aspects of one's identity without some
trusted credential issuer.

\subsection{Prior Work}
A generalized scheme was proposed by \citet{garmanDecentralizedAnonymousCredentials2013}

\section{Properties and Features}

\section{Implementation}

\subsection{Credential Scheme}

\subsection{The ZKID Service}

\subsubsection{libsnark}

\subsubsection{JSON RPC}

The ZKID client application acts as a JSON RPC service that can handle requests from client dApps. For the simplest implementation,
the RPC service offered a single procedure: GenerateProofs. This procedure takes as input all the fields nessesary
to construct the required set of public inputs for the proofs. If proof generation was successful, the service will respond with a 
set of generated proofs and relevant public inputs. The returned proofs can then be sent to the verifier contract.  

\subsection{Verifiers}

It is expected, although not required, that credential-enabled contracts perform their own proof verification. For this reason, we have
developed a Solidity library that enables contracts to verify proofs autonomously. The verifier library follows a scheme similar to that
of Zokrates [insert citation here]. The library exposes a single method to be utlized by the higher-level contract: verifyTx. This 
method does precisely what the name implies and verifies as set of proofs encoded as bytes and returns true if all proofs where sucessfully
verified and false otherwise. 

It is important to note that all verification calculations are done on-chain and therefore can potentially require immense amounts of gas.
For this reason, the number of proofs requested for verification should be kept to a minimum. 

\subsection{Issuers}

Although there is no strict template for an issuer (asside from the credential contruction), we purpose a scheme that we believe
will offers most of the elementary functions of an issuer. This basic scheme involves 2 main functions:
credential-holder stake and distributed merkle tree storage.

\subsubsection{Credential-Holder Stake}

An obvious vulenerability of the credential system as described is the ability to share credentials. So, for example, an uncredible could may
a credible party for a specific credential. We proprose that an issuer's require a credential-requester to submit a stake when 
applying for a credential. This stake can be redeemed by an user that can provide the issuer contract with a specified pre-image. Once 
redeemed, the credential because invalidated. Therefore, if a dishonest party were to give away their credential, the new holder of the credential
could steal the original holder's stake. This requires issuers to set their stakes high enough such that no party would be willing to pay the
price of the stake for the credential. A stake system could also lead to varying "tiers" of issuers where issuers that require higher stakes could be 
percieved as having higher credibility do the lower probability of users sharing said issuer's credential.

\subsubsection{InterPlanetary File System (IPFS)}

As designed, the ZKID service expects verifiers to store their issued-credential merkle trees using the distributed file system service, InterPlanetary File System (IPFS).
By utilizing IPFS, the ZKID service promotes the distributed nature of its environment and further encourages issuers to take advantage of said distributed nature. All issuer
contracts must supply a GetMerkleTreeAddress method that returns the IPFS address of their merkle root. Every issuer must also append the hashes of every issued credential 
to their merkle tree so that verifiers and clients can construct merkle tree paths and subsequently merkle tree membership proofs as nessesary. 

\subsection{dApp Framework and Credential-Enabled Contracts}

Add some Introduction here

\subsubsection{Credential Annotated ABI}
The properly interface with the ZKID Service a dApp would provide an annotated ABI for its dependant contract(s).
The annotations describe the required credentials for a given method within the smart contract and will
be used to communicate public inputs to the ZKID prooving service. An annotated ABI function
would appear as follow:

Note that the description field is not nessesary for generation / verification of proofs, but is supplied soley for
the use of the credential-acknowledgement framework described later. 

\subsubsection{ZKID web3 Framework}

To a dApp's migration to credentail-enabled contracts as smooth as possible we have supplied a ZKID framework that interfaces
with our prove-generation service and seemlessly collects and supplies verifcation arguments to credential-enabled methods. This 
allows dApp creators to integrate credential functionality without changing their already developed application code.

To utlize the framework a dApp simply replaces all existing contract calls with calls to their credential accepting counterparts. 
This can be accomplished very concisely by wrapping the credial-accepting method call with partially applied
function.

The "Join" function in the provided example application is an example of how to properly provide the ZKID framework with a partially applied credential-enabled function. Originally, took a number of non-proof arguments. 
The credential enabled join now takes the non-proof arguments as well as proof arguments. This partial application hides the non-proof arguments from the ZKID CredentialBlock and allows the CredentialBlock to 
supply the proof arguments post proof-generation. The dApp's code has now migrated its call to "Join" to a credential-enabled call with minimal additions.

\section{Benchmarks}

\section{Example Application}

To demonstrate the facilities provided by the our system we developed a simple lottery dApp that requries participants to be
both over the age of 18 and have American Citizenship to participate. Along with the dApp, we created a credential-acknowledgement
framework that would allow applications to prompt users for the required credentials before any proofs are generated.



\section{Future Work}

\section{Conclusion}

\bibliographystyle{plainnat}
\bibliography{Identity}
\end{document}